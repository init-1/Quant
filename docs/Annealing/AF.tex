\documentclass[10pt,oneside,a4paper]{article}
\input{settings}


\newcommand\modelname{Nonlinear Factor Model User Guide}
\newcommand\mytitle{\modelname}
\newcommand\myfints{\mcode{myfints}}
\newcommand{\matlab}{{\textsc{Matlab}}}

\begin{document}
\pagenumbering{roman}
\title{\textbf{\mytitle}}
\author{}
\maketitle

\tableofcontents
%\listoftables
%\listoffigures
\cleardoublepage
\lstset{backgroundcolor=\color{lightgrey},
        basicstyle=\ttfamily\footnotesize,  
        aboveskip={0.5\baselineskip},
        basewidth=0.5em}


\section{DataBase Tables}
\pagenumbering{arabic}

Three tables with scheme name \texttt{anl} are created.

\begin{argdesc}
  \item [modelmstr] Record every model using nonlinear factor combination techneque and associated parameters.

     \begin{tabular}{>{\ttfamily}l<{} l p{11cm}}
     modelid & int  & model identifier. \\
     aggid   & char & universe identifier. \\
     window  & int  & number of periods an investment cycle has, used as smoothing window. \\
     tcost   & float & transaction cost. \\
     PFMethod & char &  portfolio construction method, either 'EqualWeight' or 'SectorNeutral'\\
     prctileFilter & char & percentile filter condition for all factors, form of \texttt{[lp1 rp1; lp2 rp2 ...]},
             just like a normal 2-column matrix in \matlab{} with each row defines a percentile range,
             and stocks with factor value located in the the range(s) will be selected. \\
     specificFilter & char & allows to set different filtering percentiles for different factors, form of
            \texttt{factorid1 prctileFilter1, factorid2 prctileFilter2...} where \texttt{prctileFilter}$n$
            has the same format as that of \texttt{prctileFilter}.\\
     freq     & char & sampling frequency, used when loading data.\\
     univname & char & a name give to the universe indicated by column \texttt{aggid}.\\
     normlevel & int & normalization level when apply normalization with GICS to factor and stock data. \\
     \end{tabular}

  \item [annealingFilter] Record factors used by model

     \begin{tabular}{>{\ttfamily}l<{} l p{11cm}}
     modelid & int & mode identifier registered in table \texttt{modelstr}.\\
     caseid  & int & corresponding to every model there are many cases involved different factors.
              \texttt{caseid} used to differentiate these cases. \\
     factorid & char & factor id.\\
     \end{tabular}
   
  \item [weights] Record portfolios generated by nonlinear combination.
     
    \begin{tabular}{>{\ttfamily}l<{} l p{11cm}}
     modelid & int & mode identifier registered in table \texttt{modelstr}.\\
     caseid  & int & corresponding to every model there are many cases involved different factors.
              \texttt{caseid} used to differentiate these cases. \\
     date    & datetime & date of weight \\
     secid   & char & security identifiers \\
     weight  & float & weight of the security in the portfolio \\
    \end{tabular}

\end{argdesc}

\section{Production Usage}

To run nonlinear combination in production, invoke command like this:

\begin{lstlisting}[numbers=none]
    anl <modelid> <rundate>
\end{lstlisting}
where \texttt{modelid} is the the model identifier recored in database,
\texttt{rundate} is the date until then the data will be loaded.

In production, the program load model parameters from table \texttt{modelmstr}
and load all necessary data (stock- and factor-related) based on these parameters and 
information in table \texttt{annealingFilter}
to build an \texttt{Annealing} object, then construc protfolio upon them. 
Resulting portfolio will be stored in table \texttt{weights}.

\section{Research Usage}

In research statge, we need to build models using annealing code by trying different parameters.
The rersult is presented by a set of combinations of factors which is picked up based on their
performance measures (information ratio).
Each set of factor combination is called a case (and corresponds to a caseid in production).
After having an approriate case in hand, you can write the related information to
database (model parameters go to \texttt{modelmstr}, factor conbinations go to \texttt{annealingFilter})
for production use.

The script file \texttt{test.m} shows how to use annealing code to build a model.
There are many parameters involved controlling different aspects of annealing process.
We will now go through the script.

\begin{enumerate}
    \item Create an \texttt{Annealing} object.
\begin{lstlisting}
	if exist('o.mat', 'file')
	    load('o.mat');
	else
	    facids = mat2cell(num2str((1:220)','F%5.5d'), ones(220,1));
	    o = Annealing('00053', facids, '2003-12-31', '2011-12-31', 'M', 'SP500');
	    save('o.mat', 'o');
	end
\end{lstlisting}

Note code checking whether a cache file \texttt{o.mat} exists. 
Usually loading data from database is slow,
and we are almost always in need to try different parameter sets to a dataset.
The file \texttt{o.mat} serves as a cache so that we don't need to load the same dataset from database more than once.

If no cache file exists, \texttt{Annealing} object will be created from database using
specified universe (\texttt{aggid},1st parameter) and factors (\texttt{facids}, 2nd parameter) 
over specified period (\texttt{startDate} and \texttt{endDate}, 3rd and 4th parameters respectively)
in specified frequency (\texttt{freq}, 5th parameter).
The last parameter is an universe name associated with the first parameter (\texttt{aggid})
to provide a name to the given universe which will be used and shown in report file
generated by calling \texttt{report()} function.
Finally, in line 6 the object just created is saved to a cache file.

Note the cache mechanism is kind of rough;
\emph{if anything related to the parameters in construction is going to change,
please first remove the old cache file (if there is one).}

    \item Set parameters. 
    Most of parameters involved get default values and only need to be set if you want to try different values than the 
    default ones.
    There are a few, however, are mandatory; i.e., they must be set explicitly by users.
    The next code snippet shows all the mandatory parameters. You can refer the comments for their meaning.

\begin{lstlisting}[firstnumber=last]
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% Following parameters must be set by user, otherwise program won't work.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	%% In-sample periods
	o.samplePeriods(1).start  = '2003-12-31';
	o.samplePeriods(1).end    = '2006-08-31';
	o.samplePeriods(1).weight = 1/3;
	o.samplePeriods(2).start  = '2006-09-01';
	o.samplePeriods(2).end    = '2010-12-31';
	o.samplePeriods(2).weight = 2/3;
	% ... you can continue this with something like
	%        o.samplePeriods(3).start  = sth;
	%        o.samplePeriods(3).end    = sth;
	%        o.samplePeriods(3).weight = sth;
	% if you like.
	
	%% Hard constraint parameters, index can only be 1.
	o.hardMetrics(1).IR = 0.2;      % hard constraint: IR of factors picked must be > this value
	o.hardMetrics(1).IC = 0.005;    % hard constraint: weighted (by o.samplePeriod.weight) average of IC
                                   %    must be > this value
	o.hardMetrics(1).IC_means = [0 0];% hard constraint: average of IC in each insample period must be > 
                                     %   this value. # of elements should == number of insample periods
\end{lstlisting}

   Following parameters are optional which all get default values:

\begin{lstlisting}[firstnumber=last]
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% All the following parameters got default values. 
	% NO NEED to have them in your code if you insist on the default values.
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	%% Filtering parameters
	o.nMinFacPerType = 1;          % minimum number of factors picked up for each type; DEFAULT 1
	o.nMaxFacPerType = 1;          % maximum number of factors picked up for each type; DEFAULT 1
	o.alwaysSelected = {'F00072'}; % list of factors must be selected like 'F00072' for S&P 500; DEFAULT {}
	o.neverSelected  = {};         % list of factors never be selected; DEFAULT {}
	o.prctileFilter  = [1/3 1];    % Stocks with factor value greater than corresponding percentile value
	                               %    be selected; DEFAULT [1/3 1]
	o.tcost          = 40/10000;   % transaction cost; DEFAULT 40/10000.
	o.window         = 6;          % number of periods an investment cycle has; DEFAULT 6
	o.coverage       = 0.5;        % coverage of factors must greater than this value; DEFAULT 0.5 (50%)
	o.PFMethod  = 'EqualWeight';   % portfolio construction method, either 'EqualWeight' or 
	                               %   'SectorNeutral'; DEFAULT 'EqualWeight'
	o.specificFilter = {'F00072' [0 2/3]};  % allows to set different filtering percentiles for 
                                           %    different factors; DEFAULT {}
	
	%% Annealing parameters: increasing nIteration costs more time but gets more reliable results
	o.temperatures = 0.5 * 0.75 .^ (0:19); % temperatures to be annealed; this is the DEFAULT value
	o.nIteration   = 10000;         % number of loops for each temperature; DEFAULT 6000
\end{lstlisting}

    Note that parameters \texttt{prctileFilter}, \texttt{specificFilter}, \texttt{tcost}, \texttt{windows},
\texttt{PFMethod}, along with the constructor parameter \texttt{aggid}, \texttt{freq} and \texttt{univname}
are used in portfolio construction and therefore stored in database table \texttt{modelmstr}.

   Right after setting all parameters, you must call \texttt{applyOptions} to bring them into effect:

\begin{lstlisting}[firstnumber=last]
    o = o.applyOptions;    % must do this
\end{lstlisting}

  \item Kick off annealing by runing 

\begin{lstlisting}[firstnumber=last]
    [energies, states] = o.run(inf);
\end{lstlisting}

    where \texttt{run} can take two parameters: 
    \begin{itemize}
	    \item the first is a number specifying total number of states to be returned
	    in order of performance measure(i.e., insample IR), 
	    \item the second is optional which allow user to provide an initiate state
	    (\emph{which must satisfy the constraints specified by parameters}
	    \texttt{nMinFacPerType}, \texttt{nMaxFacPerType}, \texttt{alwaysSelected}, \emph{and} \texttt{neverSelected}). 
    \end{itemize}
    If the second parameter is omitted (this is the case in the code snippet above), \texttt{run} will internally generate 
    a qualified initial state.

  \texttt{run} returns two things:
  \begin{itemize}
	  \item the first returned (\texttt{energies}) is the peformance meansures of states selected,
	  it's a vector of size equal to the first parameter (number of states to be picked up) passed into it.
	   \footnote{Unless total number of all combinations possible are less than specified.}
	  In this case it actually the negated IR.
	  \item the second are the states matrix, with each column corresponds to a state and therefor to a portfolio,
	  and the row dimension -- number of states -- equal to length of the first returned,
	  the column dimension is the total number of factors (can be referenced by \texttt{length(o.facids)}) in dataset.
	  Value greater than 0 means the corresponding factors are selected.
  \end{itemize} 

  \item Generate report and get final nonlinearly combined portfolio weight (already smoothed over \texttt{window} periods).

\begin{lstlisting}[firstnumber=last]
	[pfw, r] = o.report('test', states(:, 1:50)); 
\end{lstlisting}

   \texttt{report} takes two parameters: the first gives the filename of the report (no file suffix needed),
   the second passes the states returned from the last step.
   You don't need to pass all states returned from step 3. 
   In this example code, we passed 50 states (\texttt{states(:,1:50)}, which correspond to 50 portfolios).
   The final portfolio returned in \texttt{pfw} is the average of these 50 portfolios.
	\texttt{r} returned in the second output argument is the final portfolio's return series.
   Both \texttt{pfw} and \texttt{r} are \myfints.

  \item Finally, you can select to write the model to database if you decide this model should go to production.

\begin{lstlisting}[numbers=none]
    modelid = o.saveModel(states(:,1:50));
\end{lstlisting}

    \texttt{modeid} returned can be used to retrieve the model back from database later by
\begin{lstlisting}[numbers=none]
    [o, caseids, states] = Annealing.LoadModel(modelid, rundate);
\end{lstlisting}
where \texttt{o} is an annealing object, \texttt{caseids} are ids for each state (columns of \texttt{states},or factor conbinations).

At this point, constructing a (nonlinear-combined) portfolio is a piece of cake:
\begin{lstlisting}[numbers=none]
    o.savePF(modelid, caseids, states);
\end{lstlisting}
which not only creates the portfolio, but also writes the portfolio weight to \texttt{weights} table.
The last two code snippets actually is all the production code in \texttt{main.m}.

\end{enumerate}


\end{document}
